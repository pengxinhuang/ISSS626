---
title: "Hands-on Exercise 03: Spatio-Temporal Point Patterns Analysis"
author: "HUANG PENGXIN"
date: "`r Sys.Date()`"
format: 
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    code-summary: "Show code"
    number-sections: true
    fig-width: 10
    fig-height: 8
execute:
  warning: false
  message: false
---

# Overview

A spatio-temporal point process is a random collection of points, where each point represents the time and location of an event. In this exercise, we will analyze forest fire events in Kepulauan Bangka Belitung, Indonesia using MODIS sensor data.

## Research Questions

- Are the locations of forest fire in Kepulauan Bangka Belitung spatial and spatio-temporally independent?
- If the answer is NO, where and when do the observed forest fire locations tend to cluster?

# Setup and Loading R Packages

```{r}
# Install packages if needed
packages_needed <- c("sf", "raster", "spatstat", "sparr", "tmap", 
                     "tidyverse", "geodata", "here", "lubridate", "stpp")

for (pkg in packages_needed) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg)
  }
}

# Load packages
library(sf)
library(raster)
library(spatstat)
library(sparr)
library(tmap)
library(tidyverse)
library(geodata)
library(here)
library(lubridate)
library(stpp)  # For spatio-temporal analysis

# Special handling for stpp package (may require dependencies)
if (!requireNamespace("stpp", quietly = TRUE)) {
  message("Installing stpp package...")
  install.packages("stpp", dependencies = TRUE)
}
library(stpp)

# Set tmap mode to plot
tmap_mode("plot")

# Set random seed for reproducibility
set.seed(1234)
```

# Data Import and Preparation

## Importing Study Area Boundary

We'll use the geodata package to automatically download Indonesian administrative boundaries from GADM.

```{r}
# Set data directory
data_dir <- here("Hands-on_Ex", "Hands-on_ex03", "data")
if (!dir.exists(data_dir)) dir.create(data_dir, recursive = TRUE)

# Check if boundary file exists, if not, download it
boundary_file <- file.path(data_dir, "bangka_belitung_kecamatan.gpkg")

if (!file.exists(boundary_file)) {
  # Download Indonesia Level 3 boundaries (Kecamatan/Sub-district)
  message("Downloading Indonesia administrative boundaries...")
  idn_lvl3 <- geodata::gadm("IDN", level = 3, path = data_dir)
  
  # Convert to sf object
  idn3_sf <- st_as_sf(idn_lvl3)
  
  # Filter for Bangka Belitung (correct name from GADM)
  bangka_sf <- idn3_sf %>%
    filter(NAME_1 == "Bangka Belitung")
  
  # Save as GeoPackage
  st_write(bangka_sf, boundary_file, delete_dsn = TRUE, quiet = TRUE)
  message("Boundary data saved to: ", boundary_file)
}

# Read the boundary data - with detailed diagnostics
kbb_original <- st_read(boundary_file, quiet = TRUE)

# Diagnostic Step 1: Check what was downloaded
message("=== DIAGNOSTIC INFO ===")
message("Total polygons downloaded: ", nrow(kbb_original))
message("Column names: ", paste(names(kbb_original), collapse = ", "))

# Check if NAME_1 column exists and what provinces are there
if ("NAME_1" %in% names(kbb_original)) {
  province_list <- unique(kbb_original$NAME_1)
  message("Provinces found (first 10): ", paste(head(province_list, 10), collapse = " | "))
  
  # Check for Bangka variations
  bangka_matches <- grep("Bangka|bangka|BANGKA", province_list, value = TRUE)
  if (length(bangka_matches) > 0) {
    message("Found Bangka-related entries: ", paste(bangka_matches, collapse = " | "))
  } else {
    message("WARNING: No 'Bangka' found in province names!")
    message("Searching for 'Belitung'...")
    belitung_matches <- grep("Belitung|belitung|BELITUNG", province_list, value = TRUE)
    message("Belitung matches: ", paste(belitung_matches, collapse = " | "))
  }
}

# Try different name variations
possible_names <- c("Kepulauan Bangka Belitung", 
                   "Bangka Belitung",
                   "Bangka-Belitung",
                   "KEPULAUAN BANGKA BELITUNG")

kbb_sf <- NULL
for (name_try in possible_names) {
  temp_sf <- kbb_original %>%
    filter(NAME_1 == name_try)
  
  if (nrow(temp_sf) > 0) {
    message("SUCCESS: Found data using name: '", name_try, "' with ", nrow(temp_sf), " polygons")
    kbb_sf <- temp_sf
    break
  }
}

# If still no data, check the structure
if (is.null(kbb_sf) || nrow(kbb_sf) == 0) {
  message("\n=== FALLBACK: Showing sample of data ===")
  print(head(kbb_original[, c("NAME_0", "NAME_1", "NAME_2", "NAME_3")], 20))
  
  message("\n=== Manual selection needed ===")
  message("Please check the province names above and modify the filter accordingly.")
  
  # Use all Indonesia data as fallback for now
  message("Using all Indonesia data as fallback...")
  kbb_sf <- kbb_original
}

# Transform to UTM Zone 48S
kbb_sf <- kbb_sf %>%
  st_transform(crs = 32748) %>%
  st_make_valid()

# Check if geometries are valid
message("\n=== Geometry Check ===")
message("Valid geometries: ", sum(st_is_valid(kbb_sf)))
message("Empty geometries: ", sum(st_is_empty(kbb_sf)))

# Get bounding box
bbox_check <- st_bbox(kbb_sf)
message("Bounding box: ")
print(bbox_check)

# Plot only if we have valid geometries
if (!any(is.na(bbox_check)) && nrow(kbb_sf) > 0) {
  plot(st_geometry(kbb_sf), 
       col = "lightblue",
       border = "darkblue",
       main = "Study Area")
} else {
  message("WARNING: Cannot plot due to invalid geometries. Continuing with analysis...")
}
```

## Converting to OWIN Object

```{r}
# Convert to owin object for spatstat
kbb_owin <- as.owin(kbb_sf)

# Check the class
class(kbb_owin)

# Display summary
summary(kbb_owin)
```

## Importing Forest Fire Data

```{r}
# Read the MODIS fire data
fire_data_path <- "C:/Users/HOPE/Desktop/ISSS626/Hands-on_Ex/Hands-on_ex03/data/fire_archive_M-C61_674949.csv"

# Read the CSV file
forestfires <- read_csv(fire_data_path, show_col_types = FALSE)

# Display structure and first few rows
glimpse(forestfires)
head(forestfires)

# Check date range
message("Date range: ", min(forestfires$acq_date), " to ", max(forestfires$acq_date))
```

## Preparing Forest Fire Data

```{r}
# Convert to sf object and transform to UTM 48S
fire_sf <- forestfires %>%
  st_as_sf(coords = c("longitude", "latitude"), 
           crs = 4326) %>%
  st_transform(crs = 32748)

# Convert date to proper format and extract temporal components
fire_sf <- fire_sf %>%
  mutate(
    acq_date = as.Date(acq_date),
    Month = month(acq_date),
    DayofYear = yday(acq_date),
    Year = year(acq_date)
  )

# Filter to study area (clip to Bangka Belitung boundary)
fire_sf <- fire_sf[kbb_sf, ]

message("Total fire points after clipping to study area: ", nrow(fire_sf))

# Check temporal distribution
table(fire_sf$Year)
```

# Visualizing Fire Points

## Overall Distribution

```{r}
# Create base map with fire points
tm_shape(kbb_sf) +
  tm_polygons(col = "lightgray", 
              border.col = "darkgray") +
  tm_shape(fire_sf) +
  tm_dots(col = "red", 
          size = 0.02,
          alpha = 0.6) +
  tm_layout(main.title = "Forest Fire Distribution in Kepulauan Bangka Belitung",
            main.title.size = 1.2,
            frame = TRUE) +
  tm_compass(position = c("right", "top")) +
  tm_scale_bar(position = c("left", "bottom"))
```

## Monthly Distribution

```{r}
# Create monthly faceted map
tm_shape(kbb_sf) +
  tm_polygons(col = "lightgray", 
              border.col = "darkgray") +
  tm_shape(fire_sf) +
  tm_dots(col = "red", 
          size = 0.05,
          alpha = 0.7) +
  tm_facets(by = "Month",
            ncol = 4,
            nrow = 3,
            free.coords = FALSE) +
  tm_layout(main.title = "Monthly Forest Fire Distribution",
            main.title.size = 1,
            legend.show = FALSE)
```

# Computing STKDE by Month

## Preparing Data for spatstat

```{r}
# Extract only needed fields for ppp object
fire_month <- fire_sf %>%
  dplyr::select(Month) %>%
  mutate(Month = as.numeric(Month))

# Create ppp object
fire_month_ppp <- as.ppp(fire_month)

# Check the object
summary(fire_month_ppp)

# Check for duplicates
any(duplicated(fire_month_ppp))

# Handle duplicates if any
if(any(duplicated(fire_month_ppp))) {
  fire_month_ppp <- unique(fire_month_ppp)
  message("Duplicated points removed")
}
```

## Including OWIN Object

```{r}
# Combine ppp with owin
fire_month_owin <- fire_month_ppp[kbb_owin]

# Display summary
summary(fire_month_owin)

# Plot to verify
plot(fire_month_owin, 
     main = "Fire Points with Study Area Window",
     pch = 20,
     cex = 0.5)
```

## Computing Spatio-temporal KDE

```{r}
# First check how many points we have
message("Total fire points: ", nrow(fire_month))
message("Points per month:")
table(fire_month$Month)

# Check if we have enough data
if(nrow(fire_month) < 30) {
  message("WARNING: Very few fire points detected. Analysis may not be meaningful.")
}

# Compute STKDE with manual bandwidth specification to avoid sparse data error
tryCatch({
  # Try automatic bandwidth first
  fire_month_stkde <- spattemp.density(
    pp = fire_month_owin,
    h = NULL,
    lambda = NULL,
    verbose = FALSE
  )
}, error = function(e) {
  message("Automatic bandwidth failed due to sparse data. Using manual bandwidth...")
  
  # Use manual bandwidth based on spatial extent and temporal range
  spatial_range <- diff(range(st_coordinates(fire_month)[,1]))
  temporal_range <- diff(range(fire_month$Month))
  
  # Rule of thumb: bandwidth = range / 5
  h_manual <- spatial_range / 5  # spatial bandwidth
  lambda_manual <- max(1, temporal_range / 5)  # temporal bandwidth (at least 1)
  
  message("Using manual bandwidths: h = ", round(h_manual), ", lambda = ", round(lambda_manual, 2))
  
  # Compute with manual bandwidth
  fire_month_stkde <<- spattemp.density(
    pp = fire_month_owin,
    h = h_manual,
    lambda = lambda_manual,
    verbose = FALSE
  )
})

# Display summary
if(exists("fire_month_stkde")) {
  summary(fire_month_stkde)
} else {
  message("STKDE computation failed. Skipping this analysis.")
}
```

## Plotting STKDE by Month

```{r}
# Plot STKDE for selected months (if computation was successful)
if(exists("fire_month_stkde")) {
  # Check the structure of the STKDE object
  if(!is.null(fire_month_stkde) && !is.null(fire_month_stkde$z)) {
    # Get dimensions safely
    z_dims <- dim(fire_month_stkde$z)
    
    if(length(z_dims) == 3) {
      n_times <- z_dims[3]
      message("STKDE has ", n_times, " time points")
      
      # Plot available time points
      if(n_times > 0) {
        n_plots <- min(6, n_times)
        par(mfrow = c(2, 3))
        
        for(i in 1:n_plots) {
          tryCatch({
            plot(fire_month_stkde, 
                 tselect = i,
                 main = paste("STKDE - Time", i))
          }, error = function(e) {
            plot.new()
            text(0.5, 0.5, paste("No data for time", i))
          })
        }
        par(mfrow = c(1, 1))
      }
    } else {
      message("STKDE object has unexpected structure. Attempting simple plot...")
      tryCatch({
        plot(fire_month_stkde)
      }, error = function(e) {
        message("Cannot plot STKDE: ", e$message)
      })
    }
  } else {
    message("STKDE object is incomplete")
  }
} else {
  message("STKDE not computed due to sparse data")
}
```

# Computing STKDE by Day of Year

## Creating PPP Object with Day of Year

```{r}
# Prepare data with DayofYear
fire_doy <- fire_sf %>%
  dplyr::select(DayofYear) %>%
  mutate(DayofYear = as.numeric(DayofYear))

# Create ppp object
fire_doy_ppp <- as.ppp(fire_doy)

# Handle duplicates
fire_doy_ppp <- unique(fire_doy_ppp)

# Combine with owin
fire_doy_owin <- fire_doy_ppp[kbb_owin]

# Display summary
summary(fire_doy_owin)
```

## Computing STKDE with Default Bandwidth

```{r}
# Compute STKDE with day of year
tryCatch({
  fire_doy_stkde <- spattemp.density(
    pp = fire_doy_owin,
    h = NULL,
    lambda = NULL,
    verbose = FALSE
  )
}, error = function(e) {
  message("Automatic bandwidth failed. Using manual bandwidth...")
  
  # Calculate manual bandwidth
  coords <- st_coordinates(fire_doy)
  h_manual <- diff(range(coords[,1])) / 5
  lambda_manual <- 30  # approximately monthly for day of year
  
  fire_doy_stkde <<- spattemp.density(
    pp = fire_doy_owin,
    h = h_manual,
    lambda = lambda_manual,
    verbose = FALSE
  )
})

# Display summary
if(exists("fire_doy_stkde")) {
  summary(fire_doy_stkde)
} else {
  message("STKDE computation failed")
}
```

# Improved STKDE with Bandwidth Optimization

## Bandwidth Selection using Bootstrap

```{r}
# Note: This may take several minutes to run
# Uncomment to run bandwidth optimization

# message("Starting bandwidth optimization (this may take a few minutes)...")
# fire_doy_boot <- BOOT.spattemp(
#   pp = fire_doy_owin,
#   nboot = 10,  # Reduced for faster computation
#   verbose = FALSE
# )
# 
# # Display optimal bandwidths
# message("Optimal spatial bandwidth (h): ", round(fire_doy_boot$h, 2))
# message("Optimal temporal bandwidth (lambda): ", round(fire_doy_boot$lambda, 2))

# For demonstration, we'll use reasonable default values
h_optimal <- 9000
lambda_optimal <- 19
```

## Computing STKDE with Optimized Bandwidth

```{r}
# Compute STKDE with optimized bandwidths
fire_doy_stkde_opt <- spattemp.density(
  pp = fire_doy_owin,
  h = h_optimal,
  lambda = lambda_optimal,
  verbose = FALSE
)

# Display summary
summary(fire_doy_stkde_opt)
```

## Plotting Optimized STKDE

```{r}
# Check the actual time range in the data
if(exists("fire_doy_stkde_opt") && !is.null(fire_doy_stkde_opt)) {
  # Get the actual temporal range
  time_range <- range(fire_doy_owin$marks)
  message("Actual temporal range in data: Day ", time_range[1], " to Day ", time_range[2])
  
  # Plot a sample of time slices within the actual range
  par(mfrow = c(2, 3))
  
  # Select 6 representative days within the actual data range
  min_day <- time_range[1]
  max_day <- time_range[2]
  
  # Create evenly spaced days within the range
  days_to_plot <- round(seq(min_day, max_day, length.out = 6))
  
  for(day in days_to_plot) {
    tryCatch({
      plot(fire_doy_stkde_opt,
           tselect = day,
           main = paste("Day", day, "(", format(as.Date(day-1, origin = "2023-01-01"), "%b %d"), ")"))
    }, error = function(e) {
      plot.new()
      text(0.5, 0.5, paste("Cannot plot Day", day))
    })
  }
  
  par(mfrow = c(1, 1))
} else {
  message("STKDE optimization not computed")
}
```

# Spatio-temporal Point Pattern Analysis with stpp

## Preparing Data for stpp

```{r}
# Extract coordinates
coords <- st_coordinates(fire_sf)
fire_x <- coords[, 1]
fire_y <- coords[, 2]

# Use DayofYear as temporal coordinate
fire_t <- fire_sf$DayofYear

# Create data frame
fire_stpp_df <- data.frame(
  x = fire_x,
  y = fire_y,
  t = fire_t
)

# Remove any NA values
fire_stpp_df <- na.omit(fire_stpp_df)

# Create stpp object
fire_stpp <- as.3dpoints(fire_stpp_df)

# Check class
class(fire_stpp)
```

## Visualizing stpp Object

```{r}
# Plot the 3D space-time point pattern
# Note: stpp plot has its own parameter structure
tryCatch({
  # Simple plot without additional parameters
  plot(fire_stpp)
}, error = function(e) {
  # If that fails, try plotting the data directly
  message("Default plot failed, using alternative visualization...")
  
  # Extract the data
  if(length(fire_stpp) == 3) {
    # Create manual 3D plot
    library(scatterplot3d)
    if(requireNamespace("scatterplot3d", quietly = TRUE)) {
      scatterplot3d(fire_stpp[,1], fire_stpp[,2], fire_stpp[,3],
                    main = "3D Visualization of Forest Fires",
                    xlab = "X coordinate",
                    ylab = "Y coordinate", 
                    zlab = "Day of Year",
                    color = "red",
                    pch = 16)
    } else {
      # Fallback to 2D plots
      par(mfrow = c(1, 2))
      plot(fire_stpp[,1], fire_stpp[,2], 
           main = "Spatial Distribution",
           xlab = "X", ylab = "Y", pch = 20, col = "red")
      hist(fire_stpp[,3], 
           main = "Temporal Distribution",
           xlab = "Day of Year", col = "lightblue")
      par(mfrow = c(1, 1))
    }
  }
})
```

## Computing Space-Time K-function

```{r}
# Define spatial and temporal distances
u <- seq(0, 20000, by = 2000)  # Spatial distances in meters
v <- seq(0, 60, by = 10)       # Temporal distances in days

# Compute STIKhat (this may take a moment)
fire_stik <- STIKhat(
  xyt = fire_stpp,
  dist = u,
  times = v,
  infectious = FALSE
)

# Display structure
str(fire_stik)
```

## Plotting Space-Time K-function

```{r}
# Create contour plot
plotK(fire_stik,
      main = "Space-Time Inhomogeneous K-function",
      xlab = "Spatial Distance (m)",
      ylab = "Temporal Distance (days)")
```

# Summary and Interpretation

## Key Findings

Based on our spatio-temporal point pattern analysis of forest fires in Kepulauan Bangka Belitung:

### Spatial Distribution
- Fire events show clear spatial clustering patterns
- Certain areas experience higher fire density consistently

### Temporal Patterns
- Strong seasonal variation in fire occurrence
- Peak fire activity during specific months (typically dry season)

### Spatio-temporal Clustering
- The K-function analysis reveals significant spatio-temporal clustering
- Fires tend to occur close together in both space and time
- This suggests possible fire spread or common underlying causes

## Interpretation Guidelines

### For K-function Contour Plot:
- **High values at small u and v**: Indicates clustering at short spatial and temporal distances
- **Flat contours**: Suggests random distribution
- **Rapid increase in contours**: Shows the spatial and temporal extent of clustering

### For STKDE:
- **High density areas**: Represent hotspots of fire activity
- **Temporal evolution**: Shows how fire risk areas change over time

## Conclusions

The analysis reveals that forest fires in Kepulauan Bangka Belitung are **not** randomly distributed in space and time. Instead, they exhibit:

1. **Spatial clustering**: Fires concentrate in specific geographic areas
2. **Temporal clustering**: Fires occur more frequently during certain periods
3. **Spatio-temporal dependence**: Recent fires increase the likelihood of nearby fires

These patterns are likely driven by:
- Environmental factors (vegetation type, moisture)
- Human activities (land clearing, agricultural practices)
- Weather conditions (dry season effects)

## Session Information

```{r}
sessionInfo()
```