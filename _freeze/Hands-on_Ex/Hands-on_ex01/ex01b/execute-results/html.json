{
  "hash": "dd74527fec6eb62a22239f3044890972",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 01b: Choropleth Mapping (Population 2024)\"\nformat: html\nexecute:\n  freeze: true\n  warning: false\n  message: false\n---\n\n## Overview\n\nThis exercise demonstrates choropleth mapping techniques using Singapore's 2024 population data. We'll create two thematic maps:\n\n1. **Aged population share (65+)** by Planning Area using quantile classification\n2. **Dependency ratio** by Planning Area using Jenks natural breaks classification\n\n## Setup and Environment\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 兜底：没装 pacman 就装\nif (!requireNamespace(\"pacman\", quietly = TRUE)) install.packages(\"pacman\")\nif (!requireNamespace(\"pacman\", quietly = TRUE)) install.packages(\"pacman\")\npacman::p_load(sf, dplyr, tidyr, readr, janitor, stringr, xml2, rvest,\n               tmap, here, units, purrr)\n\n# 需要 purrr，因为后面用到 map_chr / keep\npacman::p_load(sf, dplyr, tidyr, readr, janitor, stringr, xml2, rvest,\n               tmap, here, units, purrr)\ntmap_mode(\"plot\")\n\npath_ex01 <- here::here(\"Hands-on_Ex\", \"Hands-on_ex01\")\npath_geo  <- file.path(path_ex01, \"data\", \"geospatial\")\npath_asp  <- file.path(path_ex01, \"data\", \"aspatial\")\npath_fig  <- file.path(path_ex01, \"figures\")\nif (!dir.exists(path_fig)) dir.create(path_fig, recursive = TRUE)\n\nmessage(\"Working directory: \", getwd())\nmessage(\"tmap version: \", as.character(packageVersion(\"tmap\")))\nmessage(\"Date: \", as.character(Sys.Date()))\ntmap_options(show.messages = FALSE)  # 关闭“组件被缩放”等提示\n```\n:::\n\n\n## Data Import\n\n### Import Geospatial Data (KML)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Import Master Plan 2019 Subzone Boundary (No Sea) from KML\nkml_file <- file.path(path_geo, \"MasterPlan2019SubzoneBoundaryNoSeaKML.kml\")\n\nif (!file.exists(kml_file)) {\n  stop(\"KML file not found at: \", kml_file)\n}\n\n# Read KML file\nsubzone <- st_read(kml_file, quiet = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `URA_MP19_SUBZONE_NO_SEA_PL' from data source \n  `C:\\Users\\HOPE\\Desktop\\ISSS626\\Hands-on_Ex\\Hands-on_ex01\\data\\geospatial\\MasterPlan2019SubzoneBoundaryNoSeaKML.kml' \n  using driver `KML'\nSimple feature collection with 332 features and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 103.6057 ymin: 1.158699 xmax: 104.0885 ymax: 1.470775\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check if GEOMETRYCOLLECTION and extract polygons if needed\nif (any(st_geometry_type(subzone) == \"GEOMETRYCOLLECTION\")) {\n  message(\"Extracting POLYGON from GEOMETRYCOLLECTION...\")\n  subzone <- st_collection_extract(subzone, \"POLYGON\")\n}\n\n# Transform to SVY21 (EPSG:3414)\nsubzone <- st_transform(subzone, crs = 3414)\n\nmessage(\"CRS after transformation: EPSG:\", st_crs(subzone)$epsg)\n```\n:::\n\n\n### Parse KML Attributes\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to extract field from HTML description\nextract_kml_field <- function(html_text, field_name) {\n  if (is.na(html_text) || html_text == \"\") return(NA_character_)\n  \n  page <- read_html(html_text)\n  rows <- page %>% html_elements(\"tr\")\n  \n  # Find the row with matching field name\n  value <- rows %>%\n    keep(~ html_text2(html_element(.x, \"th\")) == field_name) %>%\n    html_element(\"td\") %>%\n    html_text2()\n  \n  if (length(value) == 0) NA_character_ else value\n}\n\n# Check if PLN_AREA_N and SUBZONE_N exist\nif (!all(c(\"PLN_AREA_N\", \"SUBZONE_N\") %in% names(subzone))) {\n  message(\"Extracting planning area and subzone names from Description field...\")\n  \n  # Extract fields from HTML description\n  subzone <- subzone %>%\n    mutate(\n      pln_area_n = map_chr(Description, extract_kml_field, \"PLN_AREA_N\"),\n      subzone_n = map_chr(Description, extract_kml_field, \"SUBZONE_N\")\n    ) %>%\n    select(-Name, -Description)\n} else {\n  # If fields exist, just rename to snake_case\n  subzone <- subzone %>%\n    clean_names()\n}\n\n# Display sample data\nmessage(\"Subzone data structure:\")\nmessage(\"- Records: \", nrow(subzone))\nmessage(\"- Planning areas: \", n_distinct(subzone$pln_area_n))\n```\n:::\n\n\n### Aggregate to Planning Area Level\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Aggregate subzones to planning area level\nplanning <- subzone %>%\n  group_by(pln_area_n) %>%\n  summarise(\n    do_union = TRUE,\n    .groups = 'drop'\n  )\n\nmessage(\"Planning areas created: \", nrow(planning))\n\n# Verify CRS\nstopifnot(st_crs(planning) == st_crs(3414))\n```\n:::\n\n\n### Import Population Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# --- Import population CSV (robust rename) ---\npop_file <- file.path(path_asp, \"respopagesextod2024.csv\")\nif (!file.exists(pop_file)) stop(\"Population CSV file not found at: \", pop_file)\n\npop_raw <- read_csv(pop_file, show_col_types = FALSE)\nmessage(\"Raw columns: \", paste(names(pop_raw), collapse = \", \"))\n\n# 标准化列名为小写下划线\npopdata <- pop_raw %>% janitor::clean_names()\n\nnm <- names(popdata)\nif (\"planning_area\"     %in% nm) popdata <- dplyr::rename(popdata, pa  = planning_area)\nif (\"planning_area_name\"%in% nm) popdata <- dplyr::rename(popdata, pa  = planning_area_name)\nif (\"age_group\"         %in% nm) popdata <- dplyr::rename(popdata, ag  = age_group)\nif (\"type_of_dwelling\"  %in% nm) popdata <- dplyr::rename(popdata, tod = type_of_dwelling)\nif (\"value\"             %in% nm) popdata <- dplyr::rename(popdata, pop = value)\n\npopdata <- popdata %>%\n  mutate(\n    pa  = str_squish(pa),\n    ag  = str_replace_all(str_to_lower(ag), \"\\\\s+\", \"_\"),\n    tod = str_squish(tod),\n    sex = str_squish(sex)\n  )\n\n\n# 映射不同写法 -> 统一到 pa / ag / sex / tod / pop\n# （左边=原始列名，右边=统一后的列名）\nalias_map <- c(\n  \"planning_area\"    = \"pa\",\n  \"planning_area_name\" = \"pa\",\n  \"pa\"               = \"pa\",\n  \"age_group\"        = \"ag\",\n  \"ag\"               = \"ag\",\n  \"sex\"              = \"sex\",\n  \"type_of_dwelling\" = \"tod\",\n  \"tod\"              = \"tod\",\n  \"value\"            = \"pop\",\n  \"population\"       = \"pop\"\n)\n\n# 只对存在的列做重命名：rename(new = old)\nmap <- alias_map[names(alias_map) %in% names(popdata)]\npopdata <- dplyr::rename(popdata, !!!setNames(names(map), map))\n\n# 现在这5列应该都在：pa / ag / sex / tod / pop\nneed <- c(\"pa\", \"ag\", \"sex\", \"tod\", \"pop\")\nmiss <- setdiff(need, names(popdata))\nif (length(miss)) stop(\"These required columns are missing after rename: \", paste(miss, collapse = \", \"))\n\n# 文本清洗：去多余空格，小写化 age_group 并把空格变下划线\npopdata <- popdata %>%\n  dplyr::mutate(\n    pa = stringr::str_squish(pa),\n    ag = stringr::str_replace_all(stringr::str_to_lower(ag), \"\\\\s+\", \"_\"),\n    tod = stringr::str_squish(tod),\n    sex = stringr::str_squish(sex)\n  )\n\nmessage(\"Normalized columns: \", paste(names(popdata), collapse = \", \"))\n```\n:::\n\n\n## Data Wrangling\n\n### Process Population Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# --- Process population BY SUBZONE (sum across Sex and TOD) ---\n\n# 前提：import-population 已 clean_names()，并把列名统一成 pa/sz/ag/sex/tod/pop/time\n# 如果你还没统一列名，请在 import-population 那块 clean_names() 后加：\n# nm <- names(popdata)\n# if (\"planning_area\" %in% nm) popdata <- dplyr::rename(popdata, pa = planning_area)\n# if (\"subzone\"       %in% nm) popdata <- dplyr::rename(popdata, sz = subzone)\n# if (\"age_group\"     %in% nm) popdata <- dplyr::rename(popdata, ag = age_group)\n# if (\"type_of_dwelling\" %in% nm) popdata <- dplyr::rename(popdata, tod = type_of_dwelling)\n# if (\"value\"         %in% nm) popdata <- dplyr::rename(popdata, pop = value)\n\n# 0) 只取 2024（如果有 time 列）\npop_w <- popdata\nif (\"time\" %in% names(pop_w)) {\n  pop_w <- pop_w %>% dplyr::filter(time == max(time, na.rm = TRUE))\n}\n\n# 1) 不再按 Sex/TOD 过滤，直接“对子区+年龄段”把人头加总（= Total）\npop_sz <- pop_w %>%\n  dplyr::group_by(sz, ag) %>%\n  dplyr::summarise(pop = sum(pop, na.rm = TRUE), .groups = \"drop\") %>%\n  # 标准化子区名，提取起始年龄\n  dplyr::mutate(\n    sz_clean  = stringr::str_squish(stringr::str_to_upper(sz)),\n    ag_start  = readr::parse_integer(stringr::str_extract(ag, \"^[0-9]+\")),\n    age_category = dplyr::case_when(\n      !is.na(ag_start) & ag_start <= 19 ~ \"young\",\n      !is.na(ag_start) & ag_start <= 64 ~ \"econ\",\n      TRUE                              ~ \"aged\"\n    )\n  ) %>%\n  dplyr::count(sz_clean, age_category, wt = pop, name = \"population\") %>%\n  tidyr::complete(sz_clean, age_category, fill = list(population = 0)) %>%\n  tidyr::pivot_wider(names_from = age_category, values_from = population, values_fill = 0)\n\n# 2) 指标（安全版）\nfor (col in c(\"young\",\"econ\",\"aged\")) if (!col %in% names(pop_sz)) pop_sz[[col]] <- 0\npop_sz <- pop_sz %>%\n  dplyr::mutate(\n    total       = young + econ + aged,\n    aged_share  = dplyr::if_else(total > 0, 100 * aged / total, 0),\n    dependency  = dplyr::if_else(econ  > 0, 100 * (young + aged) / econ, NA_real_)\n  )\n\nmessage(\"Subzone-level population rows: \", nrow(pop_sz))\n```\n:::\n\n\n### Join Spatial and Population Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# --- Build SZ -> PA bridge from KML, then aggregate to PA ---\n\n# 注意：你的子区几何对象在前文叫 subzone（若叫 mpsz，请把下行的 subzone 改成 mpsz）\nbridge <- subzone %>%\n  sf::st_drop_geometry() %>%\n  dplyr::transmute(\n    sz_clean       = stringr::str_squish(stringr::str_to_upper(subzone_n)),\n    pln_area_clean = stringr::str_squish(stringr::str_to_upper(pln_area_n))\n  ) %>%\n  dplyr::distinct()\n\n# 子区人口接上映射 → 聚合到规划区\npop_pa <- pop_sz %>%\n  dplyr::left_join(bridge, by = \"sz_clean\") %>%\n  dplyr::filter(!is.na(pln_area_clean)) %>%\n  dplyr::group_by(pln_area_clean) %>%\n  dplyr::summarise(\n    young = sum(young, na.rm = TRUE),\n    econ  = sum(econ,  na.rm = TRUE),\n    aged  = sum(aged,  na.rm = TRUE),\n    .groups = \"drop\"\n  ) %>%\n  dplyr::mutate(\n    total       = young + econ + aged,\n    aged_share  = dplyr::if_else(total > 0, 100 * aged / total, 0),\n    dependency  = dplyr::if_else(econ  > 0, 100 * (young + aged) / econ, NA_real_)\n  )\n\nmessage(\"Aggregated to planning areas: \", nrow(pop_pa), \" (expected ≈55)\")\n\n# 用 inner_join 接回规划区几何（保证有值的区才保留）\nplanning <- planning %>% dplyr::mutate(\n  pln_area_clean = stringr::str_squish(stringr::str_to_upper(pln_area_n))\n)\nplanning_pop <- planning %>%\n  dplyr::inner_join(pop_pa, by = \"pln_area_clean\")\n\n# 必须 >0（否则仍是 NA）\nstopifnot(sum(!is.na(planning_pop$aged_share)) > 0)\nstopifnot(sum(!is.na(planning_pop$dependency)) > 0)\n```\n:::\n\n\n## Create Choropleth Maps\n\n### Map A: Aged Population Share (65+)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_options(show.messages = FALSE)\n\n# Map A —— Aged 65+ share（过滤 NA，避免 Missing）\nplanning_aged <- planning_pop[!is.na(planning_pop$aged_share) & !sf::st_is_empty(planning_pop), ]\n\nmap_aged <- tm_shape(planning_aged) +\n  tm_polygons(col = \"aged_share\", style = \"quantile\", n = 5, palette = \"Reds\",\n              title = \"Aged Share (%)\") +\n  tm_layout(legend.outside = TRUE) +\n  tm_compass(type = \"8star\", size = 1.8, position = c(\"left\",\"top\")) +\n  tm_scale_bar(position = c(\"left\",\"bottom\")) +\n  tm_credits(\"Data: URA MP19 (No Sea), SingStat 2024\\nCRS: SVY21 / EPSG:3414\",\n             position = c(\"right\",\"bottom\"), size = 0.6)\n\nmap_aged\n```\n\n::: {.cell-output-display}\n![](ex01b_files/figure-html/map-aged-share-1.png){width=672}\n:::\n\n```{.r .cell-code}\ntmap_save(map_aged, file.path(path_fig, \"ex01b_aged_share_quantile.png\"),\n          width = 1600, height = 1200, dpi = 300, units = \"px\")\n```\n:::\n\n\n### Map B: Dependency Ratio\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Map B —— Dependency ratio（过滤 NA）\nplanning_dep <- planning_pop[!is.na(planning_pop$dependency) & !sf::st_is_empty(planning_pop), ]\n\nmap_dependency <- tm_shape(planning_dep) +\n  tm_polygons(col = \"dependency\", style = \"jenks\", n = 5, palette = \"PuBuGn\",\n              title = \"Dependency Ratio (%)\") +\n  tm_layout(legend.outside = TRUE) +\n  tm_compass(type = \"8star\", size = 1.8, position = c(\"left\",\"top\")) +\n  tm_scale_bar(position = c(\"left\",\"bottom\")) +\n  tm_credits(\"Data: URA MP19 (No Sea), SingStat 2024\\nCRS: SVY21 / EPSG:3414\",\n             position = c(\"right\",\"bottom\"), size = 0.6)\n\nmap_dependency\n```\n\n::: {.cell-output-display}\n![](ex01b_files/figure-html/map-dependency-1.png){width=672}\n:::\n\n```{.r .cell-code}\ntmap_save(map_dependency, file.path(path_fig, \"ex01b_dependency_jenks.png\"),\n          width = 1600, height = 1200, dpi = 300, units = \"px\")\n```\n:::\n\n\n## Results\n\nThe two choropleth maps have been successfully created and saved to the `figures` folder:\n\n### Map A: Share of Aged Population (65+)\n![Aged Population Share](figures/ex01b_aged_share_quantile.png)\n\nThis map uses **quantile classification** with 5 classes to show the distribution of aged population (65 years and above) as a percentage of total population across Singapore's planning areas. The red color ramp helps identify areas with higher concentrations of elderly residents.\n\n### Map B: Dependency Ratio\n![Dependency Ratio](figures/ex01b_dependency_jenks.png)\n\nThis map uses **Jenks natural breaks classification** with 5 classes to visualize the dependency ratio across planning areas. The dependency ratio represents the proportion of economically dependent population (young and aged) to the economically active population. The PuBuGn color scheme provides clear visual distinction between areas with different dependency levels.\n\n## Summary Statistics\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Display summary statistics\ncat(\"\\n=== Summary Statistics ===\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n=== Summary Statistics ===\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"\\nAged Population Share (%):\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nAged Population Share (%):\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(planning_pop$aged_share)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   1.639  14.964  12.790  21.026  28.801 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"\\nDependency Ratio (%):\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nDependency Ratio (%):\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(planning_pop$dependency)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n  27.30   51.08   58.48   56.26   64.18   72.89      13 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Top 5 areas with highest aged share\ncat(\"\\nTop 5 Planning Areas - Highest Aged Share:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nTop 5 Planning Areas - Highest Aged Share:\n```\n\n\n:::\n\n```{.r .cell-code}\nplanning_pop %>%\n  st_drop_geometry() %>%\n  select(pln_area_n, aged_share) %>%\n  arrange(desc(aged_share)) %>%\n  head(5) %>%\n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  pln_area_n   aged_share\n  <chr>             <dbl>\n1 OUTRAM             28.8\n2 ANG MO KIO         25.4\n3 ROCHOR             24.8\n4 SUNGEI KADUT       24.6\n5 BUKIT MERAH        24.5\n```\n\n\n:::\n\n```{.r .cell-code}\n# Top 5 areas with highest dependency ratio\ncat(\"\\nTop 5 Planning Areas - Highest Dependency Ratio:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nTop 5 Planning Areas - Highest Dependency Ratio:\n```\n\n\n:::\n\n```{.r .cell-code}\nplanning_pop %>%\n  st_drop_geometry() %>%\n  select(pln_area_n, dependency) %>%\n  arrange(desc(dependency)) %>%\n  head(5) %>%\n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  pln_area_n  dependency\n  <chr>            <dbl>\n1 OUTRAM            72.9\n2 CHANGI            71.4\n3 BUKIT TIMAH       70.6\n4 ANG MO KIO        67.9\n5 BUKIT MERAH       67.4\n```\n\n\n:::\n:::\n\n\n---\n*End of Hands-on Exercise 01b*",
    "supporting": [
      "ex01b_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}